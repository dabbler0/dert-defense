// Generated by CoffeeScript 1.10.0
(function() {
  var BasicGun, Bullet, CREDITS, FRAMERATE, LANE_HEIGHT, LAST_SOLDIER, LEFT_MOUSE_DOWN, LOST_YET, MOUSE_POS, NEXT_SOLDIER, N_LANES, N_TICKS, PADDING, RIGHT_MOUSE_DOWN, SOLDIER_SIZE, SOLDIER_SPEED, SPRITES, Soldier, Sprite, Turret, VIEWPORT_HEIGHT, VIEWPORT_WIDTH, Vector, WORLD, Wall, World, canvas, ctx, drawBackground, hidden, loadAsset, lose, tick,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  VIEWPORT_HEIGHT = 400;

  VIEWPORT_WIDTH = 600;

  N_LANES = 6;

  PADDING = 10;

  SOLDIER_SIZE = VIEWPORT_HEIGHT / N_LANES - PADDING * 2;

  LANE_HEIGHT = VIEWPORT_HEIGHT / N_LANES;

  FRAMERATE = 60;

  SOLDIER_SPEED = 1;

  SPRITES = {};

  hidden = document.getElementById('hidden');

  loadAsset = function(name) {
    var img;
    img = document.createElement('img');
    img.src = "assets/" + name + ".png";
    hidden.appendChild(img);
    SPRITES[name] = img;
    return img;
  };

  loadAsset('soldier');

  loadAsset('gun');

  loadAsset('bullet');

  loadAsset('wall');

  loadAsset('turret');

  loadAsset('background');

  canvas = document.getElementById('main');

  ctx = canvas.getContext('2d');

  Vector = (function() {
    function Vector(x1, y) {
      this.x = x1;
      this.y = y;
    }

    Vector.prototype.clone = function() {
      return new Vector(this.x, this.y);
    };

    Vector.prototype.add = function(other) {
      this.x += other.x;
      return this.y += other.y;
    };

    return Vector;

  })();

  Sprite = (function() {
    function Sprite(texture, size, pos, rotation) {
      this.texture = texture;
      this.size = size;
      this.pos = pos;
      this.rotation = rotation;
    }

    Sprite.prototype.render = function() {
      ctx.save();
      ctx.translate(this.pos.x, this.pos.y);
      ctx.rotate(this.rotation);
      ctx.drawImage(this.texture, 0, 0, this.size.x, this.size.y);
      return ctx.restore();
    };

    Sprite.prototype.tick = function() {};

    return Sprite;

  })();

  drawBackground = function() {
    var i, j, k, ref, results;
    results = [];
    for (i = k = 0, ref = N_LANES; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      results.push((function() {
        var l, ref1, results1;
        results1 = [];
        for (j = l = 0, ref1 = canvas.width / LANE_HEIGHT; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
          results1.push(ctx.drawImage(SPRITES.background, j * LANE_HEIGHT, i * LANE_HEIGHT, LANE_HEIGHT, LANE_HEIGHT));
        }
        return results1;
      })());
    }
    return results;
  };

  World = (function() {
    function World(sprites) {
      this.sprites = sprites;
      this.downflag = [];
    }

    World.prototype.render = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      return this.sprites.forEach(function(x) {
        return x.render();
      });
    };

    return World;

  })();

  Soldier = (function(superClass) {
    extend(Soldier, superClass);

    function Soldier(lane1) {
      this.lane = lane1;
      Soldier.__super__.constructor.call(this, SPRITES.soldier, new Vector(SOLDIER_SIZE, SOLDIER_SIZE), new Vector(0, this.lane * LANE_HEIGHT + PADDING), 0);
      this.health = 5;
    }

    Soldier.prototype.tick = function() {
      var encountered;
      this.pos.x += SOLDIER_SPEED;
      if (this.health <= 0) {
        CREDITS += 1;
        WORLD.downflag.push(this);
      }
      if (canvas.width - this.pos.x < (LANE_HEIGHT + this.size.x)) {
        encountered = WORLD.sprites.filter((function(_this) {
          return function(x) {
            return ((x instanceof Wall) || (x instanceof Turret)) && x.lane === _this.lane;
          };
        })(this));
        if (encountered.length > 0) {
          encountered.forEach(function(x) {
            return WORLD.downflag.push(x);
          });
          WORLD.downflag.push(this);
        }
      }
      if (this.pos.x > canvas.width) {
        return lose();
      }
    };

    return Soldier;

  })(Sprite);

  BasicGun = (function(superClass) {
    extend(BasicGun, superClass);

    function BasicGun() {
      BasicGun.__super__.constructor.call(this, SPRITES.gun, new Vector(SOLDIER_SIZE, SOLDIER_SIZE), new Vector(0, 5 * LANE_HEIGHT + PADDING), 0);
      this.lastShot = 0;
    }

    BasicGun.prototype.tick = function(n) {
      this.pos.x = MOUSE_POS.x - this.size.x / 2;
      if (n - this.lastShot > 10 && LEFT_MOUSE_DOWN) {
        WORLD.sprites.push(new Bullet(this.pos.clone(), new Vector(0, -2)));
        return this.lastShot = n;
      }
    };

    return BasicGun;

  })(Sprite);

  Bullet = (function(superClass) {
    extend(Bullet, superClass);

    function Bullet(pos, vel) {
      this.pos = pos;
      this.vel = vel;
      Bullet.__super__.constructor.call(this, SPRITES.bullet, new Vector(SOLDIER_SIZE, SOLDIER_SIZE), this.pos, 0);
    }

    Bullet.prototype.tick = function() {
      var center, el, k, len, ref, ref1, ref2, results;
      this.pos.add(this.vel);
      center = new Vector(this.pos.x + this.size.x / 2, this.pos.y + this.size.y / 2);
      ref = WORLD.sprites;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        el = ref[k];
        if (el instanceof Soldier && (el.pos.x < (ref1 = center.x) && ref1 < el.pos.x + el.size.x) && (el.pos.y < (ref2 = center.y) && ref2 < el.pos.y + el.size.y)) {
          el.health -= 1;
          results.push(WORLD.downflag.push(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return Bullet;

  })(Sprite);

  Wall = (function(superClass) {
    extend(Wall, superClass);

    function Wall(lane1) {
      this.lane = lane1;
      Wall.__super__.constructor.call(this, SPRITES.wall, new Vector(LANE_HEIGHT, LANE_HEIGHT), new Vector(canvas.width - LANE_HEIGHT, this.lane * LANE_HEIGHT), 0);
    }

    return Wall;

  })(Sprite);

  Turret = (function(superClass) {
    extend(Turret, superClass);

    function Turret(lane1) {
      this.lane = lane1;
      Turret.__super__.constructor.call(this, SPRITES.turret, new Vector(LANE_HEIGHT, LANE_HEIGHT), new Vector(canvas.width - LANE_HEIGHT, this.lane * LANE_HEIGHT), 0);
      this.lastFired = 0;
    }

    Turret.prototype.tick = function(n) {
      if (n - this.lastFired > 150) {
        WORLD.sprites.push(new Bullet(this.pos.clone(), new Vector(-1, 0)));
        return this.lastFired = n;
      }
    };

    return Turret;

  })(Sprite);

  MOUSE_POS = new Vector(0, 0);

  canvas.addEventListener('mousemove', function(event) {
    MOUSE_POS.x = event.offsetX;
    return MOUSE_POS.y = event.offsetY;
  });

  LEFT_MOUSE_DOWN = false;

  RIGHT_MOUSE_DOWN = false;

  canvas.addEventListener('mousedown', function(event) {
    var lane, turrets, walls;
    if (event.which === 1) {
      LEFT_MOUSE_DOWN = true;
    } else if (event.which === 2) {
      RIGHT_MOUSE_DOWN = true;
    }
    if (canvas.width - event.offsetX < LANE_HEIGHT && CREDITS >= 5) {
      lane = Math.floor(event.offsetY / LANE_HEIGHT);
      walls = WORLD.sprites.filter(function(x) {
        return (x instanceof Wall) && x.lane === lane;
      });
      turrets = WORLD.sprites.filter(function(x) {
        return (x instanceof Turret) && x.lane === lane;
      });
      if (walls.length > 0 && turrets.length === 0) {
        WORLD.sprites.push(new Turret(lane));
        CREDITS -= 5;
      }
    }
    return console.log(event.which);
  });

  canvas.addEventListener('mouseup', function(event) {
    if (event.which === 1) {
      LEFT_MOUSE_DOWN = false;
    } else if (event.which === 2) {
      RIGHT_MOUSE_DOWN = false;
    }
    return console.log(event.which);
  });

  WORLD = new World([new BasicGun(), new Wall(0), new Wall(1), new Wall(2), new Wall(3), new Wall(4), new Wall(5)]);

  N_TICKS = 0;

  LAST_SOLDIER = 0;

  NEXT_SOLDIER = 60 * Math.random() * 4 + 60;

  LOST_YET = false;

  CREDITS = 5;

  tick = function() {
    if (!LOST_YET) {
      N_TICKS += 1;
      setTimeout(tick, 1000 / FRAMERATE);
      WORLD.render();
      ctx.font = '20px Arial';
      ctx.fillStyle = '#FFF';
      ctx.fillText('$' + CREDITS, 0, 20);
      WORLD.sprites.forEach(function(x) {
        return x.tick(N_TICKS);
      });
      if (N_TICKS - LAST_SOLDIER > NEXT_SOLDIER) {
        WORLD.sprites.push(new Soldier(Math.floor(Math.random() * 5)));
        NEXT_SOLDIER = 60 * Math.random() * 4 + 60;
        LAST_SOLDIER = N_TICKS;
      }
      WORLD.sprites = WORLD.sprites.filter(function(x) {
        return indexOf.call(WORLD.downflag, x) < 0;
      });
      return WORLD.downflag = [];
    }
  };

  tick();

  lose = function() {
    LOST_YET = true;
    return ctx.fillText('YOU LOSE', canvas.width / 2 - ctx.measureText('YOU LOSE').width / 2, canvas.height / 2);
  };

}).call(this);
